<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jsrsasign/8.0.4/jsrsasign-all-min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/load-svg-file/dist/load-svg-file.js"></script>
	<script src="https://apis.google.com/js/api.js"></script>
      <style>
	  
.movingLips {
  d: path("m282,173 c-1.19014,34.35331 -96.16325,34.35331 -94.97311,0.97102 c 1.19014, 14.35331 96.16325, 14.35331 94.97311, -0.97102");
  animation: mouth 1s ease-in 1;
}

@keyframes mouth {
    
  25% {
     path("m282,173 c-1.19014,34.35331 -96.16325,34.35331 -94.97311,0.97102 c 1.19014, 14.35331 96.16325, 14.35331 94.97311, -0.97102");
  }
  75% {
     d: path("m282,173 c-1.19014,34.35331 -96.16325,34.35331 -94.97311,0.97102 c 1.19014, -5 96.16325, -5 94.97311, -0.97102");
  }
}

/*
======
rollerRight
======
*/
.rollerRight{
	animation-name: rollerRight;
	-webkit-animation-name: rollerRight;	

	animation-duration: 2s;	
	-webkit-animation-duration: 2s;

	animation-timing-function: ease;	
	-webkit-animation-timing-function: ease;

	animation-iteration-count: 1;
	-webkit-animation-iteration-count: 1;

	-webkit-animation-fill-mode: forwards;
    animation-fill-mode: forwards;

}
@keyframes rollerRight {
  0% {
  	transform: translateX(-200px) rotate(0);
  	opacity: 0;	
  }				
  100% {
  	transform: translateX(0) rotate(2turn);
  	opacity: 1;
  }
}
@-webkit-keyframes rollerRight {
  0% {
  	-webkit-transform: translateX(-200px) rotate(0);
	opacity: 0;	
  }				
100% {
	-webkit-transform: translateX(0) rotate(2turn);
	opacity: 1;	
  }
}

/*
======
rollerLeft
======
*/

.rollerLeft{
	animation-name: rollerLeft;
	-webkit-animation-name: rollerLeft;	

	animation-duration: 2s;	
	-webkit-animation-duration: 2s;

	animation-timing-function: ease;	
	-webkit-animation-timing-function: ease;

	animation-iteration-count: 1;
	-webkit-animation-iteration-count: 1;

	-webkit-animation-fill-mode: forwards;
    animation-fill-mode: forwards;

}
@keyframes rollerLeft {
  0% {
  	transform: translateX(200px) rotate(0);
  	opacity: 0;	
  }	
  100% {
  	transform: translateX(0) rotate(-2turn);
  	opacity: 1;	
  }
}
@-webkit-keyframes rollerLeft {
  0% {
  	-webkit-transform: translateX(200px) rotate(0);
  	opacity: 0;	
  }				
  100% {
  	-webkit-transform: translateX(0) rotate(-2turn);
	opacity: 1;	
  }
}



 
</style>
    <title>speech recognition and query</title>
  </head>
  <body>
    <header>
      <h1>Browser speech recognition and talking</h1>
    </header>
<div id = "frogDIV" >
<svg width="480" height="600" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg">
 <!-- Created with SVG-edit - https://github.com/SVG-Edit/svgedit-->
 <g class="layer" xmlns="http://www.w3.org/2000/svg">
  <title>Layer 1</title>
  <ellipse cx="364.08713" cy="366.26923" fill="#007f3f" id="svg_5" rx="41.29911" ry="88.70418" stroke="#000000" transform="matrix(0.807959 0.550067 -0.536997 0.828991 264.581 -138.516)"/>
  <ellipse cx="116.72481" cy="341.90808" fill="#007f3f" id="svg_6" rx="45.20838" ry="84.24443" stroke="#000000" transform="matrix(1 0 0 1 0 0) matrix(0.806345 -0.650177 0.591446 0.886416 -182.51 135.067)"/>
  <circle cx="236" cy="321.5" fill="#007f3f" id="svg_8" r="126.20596" stroke="#007f3f" transform="matrix(1 0 0 1 0 0)"/>
  <ellipse cx="237" cy="298.5" fill="#00bf5f" id="svg_12" rx="80" ry="103.5" stroke="#00bf5f"/>
  <ellipse cx="236" cy="166.5" fill="#007f3f" id="svg_13" rx="113" ry="92.5" stroke="#007f7f" stroke-width="4"/>
  <circle cx="176" cy="94" fill="#007f3f" id="svg_14" r="46.31129" stroke="#007f3f"/>
  <circle cx="298" cy="96" fill="#007f3f" id="svg_15" r="46" stroke="#007f3f"/>
  <circle cx="178.5" cy="97" fill="#ffffff" id="svg_16" r="32" stroke="#007f3f"/>
  <circle cx="294" cy="100" fill="#ffffff" id="svg_17" r="34.20526" stroke="#007f3f"/>
  <circle cx="178.5" cy="101.5" fill="#000000" id="svg_18" r="18.33287" stroke="#000000"/>
  <circle cx="293.5" cy="105.5" fill="#000000" id="svg_19" r="19.36068" stroke="#000000"/>
  <path d="m170.93236,442.41688c-1.19014,-51.60446 -96.16325,-51.60446 -94.97311,1.45864" fill="#007f3f" id="footLeft" stroke="#007f3f" transform="matrix(1 0 0 1 0 0)"/>
  <path d="m394.49212,443.53215c-1.19014,-51.60446 -96.16325,-51.60446 -94.97311,1.45864" fill="#007f3f" id="footRight" stroke="#007f3f"/>
 </g>
 <g class="layer">
  <title>Layer 2</title>
  <path d="m282,173 c-1.19014,34.35331 -96.16325,34.35331 -94.97311,0.97102 c 1.19014, 14.35331 96.16325, 14.35331 94.97311, -0.97102" fill="red" id="lipsPath" stroke="#007f3f"/>
 </g>
</svg>
</div>
    <div>
      <button id="button">Start listening</button>
      <div id="result"></div>
      <p id="message" hidden aria-hidden="true">
        Your browser doesn't support Speech Recognition. Sorry.
      </p>
	  <p id="inputText">    </p>
    </div>
</div>



    <script>
// This works well!
//===================== get token:
	let private_key_id = "a25b2b8b62a756b18480a6422ac0a0807b3dba83";
	let private_key ="-----BEGIN PRIVATE KEY-----\nMIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCNLWQ3eKTPjke+\n9V5G+hQLOAxW8/1+y2IVIvYzbrnLY/uFh8jY1g+EPItTu89aC1uCcXfigLJe47GJ\nnUsYIu8I2703SSdj2iumt9yOPaRohJ3owxQCD5VaGaM8wVGM+pPS/p/BPDLWYU+y\nvICDH92ce6dhiFbfbL9T4fw95RbVY58Fs0E90Jufb75PyywKLFUqc98tIURhkGL3\nBr969TBGSrz+H8crwiZy39J7WSQ7Tmhnyj8/MtGHvM4xMy8lxTGK3QaBmFs3wmqY\nKcnMOsElBfMJDeBOYa9iy3Dwt8ZdX2O2/WylSEr9gqLWU/X2rEmqj647nKcu4Zq7\n3wfw9/69AgMBAAECggEAEoO1LKQtAw5PAO9XX5oM1mLRlXa2lDISiSCWZqza/147\nnmmuEKfUDZzODdtnyFCMffkpBoKnwdN9FUXUUxRDwmbk8/LrUEhMqLbcnSfe35ki\nx2OMBHAsP0507rMQoZs8FzPu2g3twdkttUxM00Vy0AKUczFI6VCu786HgMuCONY/\np1t3iTlHj0V8WckMlcqbQ/dMeYlZpKZstB2q6gKMaRCuwo1hso4UfxHzgfCMZWR3\nKY2wiVmBePQXpBqCO6/d1fnHYdN2OGRNaUoFG8YiaZvLweP6gXAVXYItvhjUvddq\nc+Bxuqnxgh3MGC1T1kNSOCr+bQUOddGNl5XZaYMBEQKBgQC/m2YxgMU+X2aLsli8\n8xBajv7+AjzCZWBazdfYWz7g3dLgrO8fx3vci/m+H7uPXSDij965KM66KkFzWfN8\neeNI5uD2B4A6jx0aT7URtnetJziAyyIL/MtYvaKjMRIChcyWTdCHS0VL4fsDBtLO\nfZiaelYP+i/sMrU8DNkXI4UqkQKBgQC8n1pi4wTkcCkjn/HNF0wUvfJHX9d+WAPC\niSgFfhL5w3m0gG0DswEtU1tyjPvKeAg6xpEdQXtpSMdm9S3NOC9GtzkEdncNkCdi\nxvUgwgFLcexLE19z64YvhNzup02TF7/UWYD2cgGfCifZiS7XWNB5PU87eJxOXFA/\n0lffntBvbQKBgCNYDgTJpRi5TlgsgNPx3i1mPUErtnuBacG2QL+HLVUbdf+9xqpN\nCNsI8vuQLO/oFN3V/haXoXKTwtj9Wb23WiajeBHKFmw24/5rf5IR34eQOYsAbXpa\nmkP3Tx3dOl4+whtjpTifuNujhsLrKk2uu0ybjm6KDvb575ZxJEZxZeoRAoGANb7q\nUFcDo9vZvQ7sJVZIFXjyOigzDQsjNyFByB7eZVCvsyEM7wrogPPJkOBfNpfxMF44\nJy/rbFqShuHBxUIHJo06r+zZi4HR1zF903G0UL0LaXEBt9Qajhu7oD0Hu6v+uxEt\n0As4LwsDw9Z1BGOIM6OmmfmKAEIJk8XpyAxGtBkCgYAlIv6t8m39R9oeybg19tk6\n0DZXeHq0c6xCtbCsIdFQQflBLFA3Im7MBgF3eh8AiWLrl1bpEH9MirURAW+Qfj+m\nyGHkJkmT/kiSRJyEsWQKW9ZyzS6ywYfxNdfEegwkgizvtKNcfseHwXjKRnfsS41T\n3hrmUWUUT9va2lw9U/glWA==\n-----END PRIVATE KEY-----\n";	
	let client_email = "megan1@meganmega-trpo.iam.gserviceaccount.com";
	const header = {
        alg: 'RS256',
        typ: 'JWT',
        kid: private_key_id  ////???
      }

      // Payload
      const payload = {
        iss: client_email,
        sub: client_email,
        iat: KJUR.jws.IntDate.get('now'),
        exp: KJUR.jws.IntDate.get('now + 1hour'),
        aud: 'https://dialogflow.googleapis.com/google.cloud.dialogflow.v2.Sessions'	
      }
      
      const stringHeader = JSON.stringify(header);
      const stringPayload = JSON.stringify(payload);
      var token = KJUR.jws.JWS.sign('RS256', stringHeader, stringPayload, private_key);
	
	console.log("token: " + token);
//====== Got token for Dialogflow service  
var base_url = 'https://dialogflow.googleapis.com/v2/projects/meganmega-trpo/agent/sessions'; // need to replace the project_id for different project
var languageCode = 'en-US';
 async function queryDialog(input_data){
 console.log("input_data2:" + input_data )
  const response = await fetch(
  base_url + "/1234567:detectIntent", {

		    method: 'POST',	
			
			headers: {
				"Accept": "application/json, text/plain, */*",
                "Content-Type": "application/json",

                "Authorization": "Bearer " + token,

            },

			
            body: JSON.stringify(input_data)

        });
		
		
	 const data = await response.json();
	// console.log(data);
	 console.log("result-fulfillmentText: ", data.queryResult.fulfillmentText);
	 console.log("result-fulfillmentMessages: ", data.queryResult.fulfillmentMessages);
	 console.log("result-fulfillmentMessages-0: ", data.queryResult.fulfillmentMessages[0]);
	 console.log("result-fulfillmentMessages-0text: ", data.queryResult.fulfillmentMessages[0].text[0]);
	 console.log("result-fulfillmentMessages-1: ", data.queryResult.fulfillmentMessages[1]);
	 console.log("result-fulfillmentMessages-1payload: ", data.queryResult.fulfillmentMessages[1].payload);
	 console.log("result-fulfillmentMessages-1payload: ", data.queryResult.fulfillmentMessages[1].payload.water);
	 speak(data.queryResult.fulfillmentText);
};	
//

var frogDIV = document.querySelector("#frogDIV");

var frogSVG =  frogDIV.querySelector("svg");
var lipsPath = frogSVG.querySelector('#lipsPath')
console.log("lipsPath:" + lipsPath);
frogSVG.classList.add('rollerRight');
frogSVG.onanimationend = (event) => { // remove animation for next time trigger
    console.log('Animation ended');
	event.stopPropagation();
    frogSVG.classList.remove('rollerRight');
	 };
lipsPath.classList.add("movingLips");
	// 
let inputText = document.querySelector("#inputText");
const button = document.getElementById("button");
var listening= false;
var speaking= false;
const result = document.getElementById("result");
const main = document.getElementsByTagName("main")[0];  //-------
const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
const recognition = new SpeechRecognition();
		  
const start = () => {
      if (!listening) {	
	  recognition.start();};
	listening = true;
	button.textContent = "Stop listening";
		 };		  
		  
const stop = () => {
		listening = false;
        recognition.stop();
        button.textContent = "Start listening";
         };



recognition.onend = function() {
		console.log('Speech recognition service end');
		listening = false;
		button.textContent = "Start listening";
		if (speaking == false) {
			startListening();
			}
		}
			
const onResult = event => {
        inputText.innerHTML = "";
        for (const res of event.results) {
             const text = document.createTextNode(res[0].transcript);
			 recogitionText =res[0].transcript;
             if (res.isFinal) {
                inputText.innerHTML = recogitionText;
              }

            }
		sendRecogitionText(recogitionText);
          };
		  
recognition.continuous = false;
          //recognition.interimResults = false; //True is the same result, why?
recognition.addEventListener("result", onResult);

button.addEventListener("click", event => {
            listening ? stop() : start();
            listening = !listening;
          });
		
if (typeof SpeechRecognition == "undefined") {
    button.remove();
    inputText.innerHTML = "The browser does not support speech recognition.";
        }   		

	  //////  

	var recogitionText ="";

	const sendRecogitionText = (order) => {
	console.log("function get order:" + order);
	//go to Dialogflow:
	//	 
	let query =order;
	let query_data = {"queryInput": {"text": {"text":query,"languageCode":"en-US"}}};
	console.log("query:" + query_data );
	queryDialog(query_data);
	}
	
const speak = message => {
  const msg = new SpeechSynthesisUtterance(message)
  msg.lang = 'en-US';
  var voices = window.speechSynthesis.getVoices();
  msg.voice = voices[4];
  msg.pitch = 1;
  speaking = true;
  window.speechSynthesis.speak(msg);
  
  msg.onstart = function(event) {
  setTimeout(function(){ 
  lipsPath.style.animationIterationCount = "infinite" }, 200); 
  //when speaking, stop listening:
  stop();
  }
  
  msg.onend = function(event) {
  lipsPath.style.animationIterationCount = "0";  // stop lips' moving.
  speaking = false;
  console.log('msg has finished being spoken after ' + event.elapsedTime + ' milliseconds.');
  if (listening == false) {
	startListening();
	}
  }
}
//speak("welcome");//
function startListening() {
  listening= true;
  recognition.start();
  button.textContent = "Stop listening";
  }

  </script>

  </body>
</html>